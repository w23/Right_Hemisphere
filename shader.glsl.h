/* File generated with Shader Minifier 1.1.4
 * http://www.ctrl-alt-test.fr
 */
#ifndef SHADER_GLSL_H_
# define SHADER_GLSL_H_
# define VAR_FADE "v"
# define VAR_DISTORT "n"
# define VAR_GREYSCALE "x"
# define VAR_GREYSCALE2 "f"
# define VAR_RED "c"
# define VAR_SHIFT11 "m"
# define VAR_SHIFTX "a"
# define VAR_SHIFTY "e"
# define VAR_SKIP "g"
# define VAR_STEPS "i"
# define VAR_T "y"
# define VAR_TIMESHIFT "l"
# define VAR_ZOOMXY "k"
# define VAR_ZOOMSHIFT "z"

const char *shader_glsl =
 "uniform float y,v,m,z,i,x,f,l,a,e,k,c,g,n;"
 "vec3 r[16];"
 "float s;"
 "vec3 p(vec3 y,vec3 i)"
 "{"
   "vec3 v=sin(i),l=cos(i);"
   "return y*mat3(l.y,v.z*v.y,-v.y*l.z,-v.x*v.y,l.x*l.z+v.x*v.z*l.y,v.z*l.x-v.x*l.z*l.y,l.x*v.y,v.x*l.z-l.x*v.z*l.y,v.z*v.x+l.x*l.z*l.y);"
 "}"
 "vec3 p(float y,float v,float z)"
 "{"
   "return vec3(y*4.-2.,v*4.-2.,z*4.-2.);"
 "}"
 "float t(vec3 v,vec3 r)"
 "{"
   "vec3 i,f,z=vec3(.5,.5,.001);"
   "f=r;"
   "r.z=(r.z+s)*4.;"
   "i=v-r;"
   "i=p(i,(y+l)/29.*f);"
   "f=max(i-z,-i-z);"
   "return max(max(f.x,f.y),f.z);"
 "}"
 "void main()"
 "{"
   "s=z+smoothstep(120.,180.,y+l)*.6-smoothstep(240.,300.,y+l);"
   "r[0]=p(.044677,.928527,.337524);"
   "r[1]=p(.520019,.026367,.486328);"
   "r[2]=p(.026125,.984497,.337249);"
   "r[3]=p(.635498,.42041,.41748);"
   "r[4]=p(.558349,.929687,.849609);"
   "r[5]=p(.840576,.539917,.436889);"
   "r[6]=p(.096557,.049438,.537475);"
   "r[7]=p(.439819,.906127,.853759);"
   "r[8]=p(.291748,.75415,.479736);"
   "r[9]=p(.572753,.774047,.402343);"
   "r[10]=p(.565551,.614624,.542602);"
   "r[11]=p(.279052,.261779,.26455);"
   "r[12]=p(.62207,.145751,.537809);"
   "r[13]=p(.846801,.8208,.397094);"
   "r[14]=p(.905029,.469421,.400512);"
   "r[15]=p(.725585,.835769,.054077);"
   "r[11]-=m/vec3(70.,110.,-180.);"
   "float b,o,u,h=.0001,d,F=.00015;"
   "vec3 C,Z=vec3(0.),Y,X,W,V,U,T=vec3(.5,.5,.001),S=vec3(0.,0.,0.),R=vec3(h,0.,0.),Q=vec3(0.,h,0.),P=vec3(0.,0.,h);"
   "for(int O=0;O<3;O++)"
     "{"
       "d=.00015;"
       "for(int N=0;N<3;N++)"
         "{"
           "vec2 M=(gl_FragCoord.xy/vec2(1920.,1080.)+vec2(d,F)+vec2(a,e))/vec2(1.,16./9.)*k;"
           "b=1.;"
           "C=normalize(vec3(M,1.));"
           "for(int L=0;L<5;L++)"
             "{"
               "if(L>=int(i))"
                 "break;"
               "o=26.;"
               "for(int K=0;K<15;K++)"
                 "if(K!=int(g))"
                   "Y=r[K],Y.z=(Y.z+s)*4.,o=min(o,length(C*b-Y)-.71);"
               "if(o<h)"
                 "break;"
               "b+=o;"
               "if(b>26.)"
                 "break;"
             "}"
           "if(b<26.)"
             "{"
               "if(mod(M.y,.08)<.04)"
                 "b-=n;"
               "C*=b;"
               "o=26.;"
               "for(int K=0;K<15;K++)"
                 "{"
                   "Y=r[K];"
                   "V=Y;"
                   "W=Y;"
                   "Y.z=(Y.z+s)*4.;"
                   "X=C-Y;"
                   "X=p(X,(y+l)/29.*W);"
                   "W=max(X-T,-X-T);"
                   "u=max(max(W.x,W.y),W.z);"
                   "if(u<o)"
                     "o=u,U=V;"
                 "}"
               "S=normalize(vec3(t(C+R,U)-t(C-R,U),t(C+Q,U)-t(C-Q,U),t(C+P,U)-t(C-P,U)));"
             "}"
           "Y=vec3(S.xy,vec3(1.-b/20.));"
           "Y.z+=Y.y/2.;"
           "Y.y=Y.y+Y.x;"
           "Z+=clamp(Y,0.,1.);"
           "d+=.0003;"
         "}"
       "F+=.0003;"
     "}"
   "Z/=9.;"
   "Z=(1.-x)*Z+vec3(Z.x+Z.z*f)*x;"
   "Z.xz+=c*vec2(abs(S.y),Z.z/3.);"
   "gl_FragColor=vec4(Z*v,1.);"
 "}";

#endif // SHADER_GLSL_H_
