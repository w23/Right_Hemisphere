{"totalDuration":4440,"variables":{"Fade":{"frames":{"0":0,"330":1,"4071":1,"4380":0,"14130":1,"14400":0},"min":0,"max":1},"shift11":{"frames":{"90":1,"900":0.2892307692307692,"3600":0.5507692307692308},"min":0,"max":300},"zoomshift":{"frames":{"2880":0.3417721518987341,"2881":0.9111392405063291,"2910":0.9046153846153846,"3360":0.3417721518987341,"3369":0.720327287066246,"3375":0.6892744479495267,"3380":0.7050473186119874,"3386":0.692429022082019,"3390":0.695583596214511,"3600":0.49367088607594933},"min":0.1,"max":8},"steps":{"frames":{"2880":0.5,"2881":0},"min":1,"max":5},"greyscale":{"frames":{"2880":0,"2881":1},"min":0,"max":1},"greyscale2":{"frames":{"3120":0,"3121":0.8501577287066246,"3142":0.4305993690851735,"3240":0.22870662460567825,"3360":0.20977917981072558,"3367":0.4085173501577287,"3370":1,"3471":1,"3600":0.5},"min":0,"max":1}},"fragment":"// Right Hemisphere intro\n\nprecision highp float;\nvarying vec2 coordVar;\nuniform float t, Fade, shift11, zoomshift, steps, greyscale, greyscale2;\n\n\nvec3 massive[16]; // coordinates\nfloat zoom;\n\nvec3 rotate(vec3 p, vec3 a)\n{\n    vec3 s = sin(a), c = cos(a);\n    return p * mat3(\n         c.y,     s.z*s.y,            -s.y*c.z,\n        -s.x*s.y, c.x*c.z+s.x*s.z*c.y, s.z*c.x-s.x*c.z*c.y,\n         c.x*s.y, s.x*c.z-c.x*s.z*c.y, s.z*s.x+c.x*c.z*c.y\n    );\n}\n\nvec3 fill(float x, float y, float z)\n{\n    return vec3(x*4.-2.,y*4.-2.,z*4.-2.);\n}\n\n\nfloat spheres(vec3 o)\n{\n    vec3 c; // moved vector, center, rotation\n    float d=26.; // distance\n\n    for (int i=0; i<15; i++)\n    {\n        c = massive[i];\n        c.z = ( c.z + zoom ) * 4.;\n        d = min( d, length(o - c)-0.71 ); // sphere distance function\n    }\n    return d;\n}\n\n\nvec3 findSquare(vec3 o)\n{\n    vec3 p, c, r, found1, found2; // moved vector, center, rotation, found square\n    vec3 s = vec3(.5,.5,.001); // square size\n    float d=26., d2; // distance\n\n    for (int i=0; i<15; i++)\n    {\n        c = massive[i];\n        found1 = c;\n        r = c;\n        c.z = ( c.z + zoom ) * 4.;\n        p = o - c; // move square to 0,0,0\n        p = rotate(p, (t+6.)/29. * r); // rotate over axis x,y,z\n        r = max(p - s, -p - s); // differences\n        d2 = max(max(r.x,r.y),r.z); // cube distance function\n        if (d2 < d)\n        {\n            d = d2;\n            found2 = found1;\n        }\n    }\n    return found2;\n}\n\nfloat squareSingle(vec3 o, vec3 c) // input: ray position, square center\n{\n    vec3 p, r; // moved vector, rotation\n    vec3 s = vec3(.5,.5,.001); // square size\n\n    r = c;\n    c.z = ( c.z + zoom ) * 4.;\n    p = o - c; // move square to 0,0,0\n    p = rotate(p, (t+6.)/29. * r); // rotate over axis x,y,z\n    r = max(p - s, -p - s); // differences\n\n    return max(max(r.x,r.y),r.z); // cube distance function\n}\n\n\nvoid main()\n{\n  \n    zoom = zoomshift + smoothstep(120.,180.,t+6.)*.6 - smoothstep(240.,300.,t+6.);\n    \n// objects coordinates\n\n    massive[0] = fill(.044677,.928527,.337524);\n    massive[1] = fill(.520019,.026367,.486328);\n    massive[2] = fill(.026125,.984497,.337249);\n    massive[3] = fill(.635498,.420410,.417480);\n    massive[4] = fill(.558349,.929687,.849609);\n    massive[5] = fill(.840576,.539917,.436889);\n    massive[6] = fill(.096557,.049438,.537475);\n    massive[7] = fill(.439819,.906127,.853759);\n    massive[8] = fill(.291748,.754150,.479736);\n    massive[9] = fill(.572753,.774047,.402343);\n    massive[10]= fill(.565551,.614624,.542602);\n    massive[11]= fill(.279052,.261779,.264550);\n    massive[12]= fill(.622070,.145751,.537809);\n    massive[13]= fill(.846801,.820800,.397094);\n    massive[14]= fill(.905029,.469421,.400512);\n    massive[15]= fill(.725585,.835769,.054077);    \n    \n    massive[11]-=shift11/vec3(70.,110.,-180.); // move closest object \n\n\n    vec3 xyz, color = vec3(0.), c, grey; // 3d-coordinates, final color, aa-color\n    \n//float aay = 0.17; // antialiasing\n//for (int by=0; by<3; by++)\n//{\n//\tfloat aax = 0.17;\n//\tfor (int bx=0; bx<3; bx++)\n//\t{\n    vec2 uv = (coordVar  - vec2(.5)) / vec2(1., 16./9.) *1.4;\n//\tvec2 uv = (coordVar  + vec2(aax,aay)  - vec2(.5)) / vec2(1., 16./9.) *1.4;\n\n// raymarching\n    xyz = normalize(vec3(uv, 1.)); // view direction\n    \n    float l = 1., d, e = .0001; // ray length, current distance, epsilon\n    vec3 norm = vec3(0.,0.,0.),\n         ex = vec3(e,0.,0.), ey = vec3(0.,e,0.), ez = vec3(0.,0.,e);\n\n    for (int i=0; i<3; i++) // trace to bounding sphere for the faster computation\n    {\n        d = spheres(xyz*l);\n        if (d<e) break;\n        l += d;\n        if (l>26.) break;\n        if (steps<2.) break;\n    }\n\n    if (l<26.)\n    {\n        xyz *= l; // actual point\n        c = findSquare(xyz); // find a square at the actual point\n        norm = normalize(vec3(\n        squareSingle(xyz+ex,c)-squareSingle(xyz-ex,c),\n        squareSingle(xyz+ey,c)-squareSingle(xyz-ey,c),\n        squareSingle(xyz+ez,c)-squareSingle(xyz-ez,c)));\n\t}\n\n    \n    c = vec3(norm.xy,vec3(1.-l/20.));\n\n    c.z+=c.y/2.; c.y=c.y+c.x; // colour correction\n\n    color += clamp(c, 0., 1.); // accumulate aa-color\n\n//    aax += .33; // end of antialiasing loop \n// \t}\n//    aay += .33;\n//}  \n//    color /= 9.; // normalize aa-color\n\n    grey = vec3(color.r+color.b*greyscale2);\n    color = (1.-greyscale)*color+grey*greyscale;\n\n    gl_FragColor = vec4(color * Fade, 1.);\n}\n"}